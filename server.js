// ============================
// server.js â€“ Vapi Tone-Aware Batch Dialer + Webhook (XXXL EDITION)
// ============================

require("dotenv").config();
const express = require("express");
const bodyParser = require("body-parser");
const { google } = require("googleapis");
const fetch = require("node-fetch"); // v2
const path = require("path");

// ---------- Constants ----------
const HOTLINE = "1-866-379-5131";
const SHEET_NAME = "outbound_list"; // must match your sheet tab
const YES_SYNONYMS = ["yes", "yep", "yeah", "yup", "sure", "correct", "affirmative", "ok", "okay"];
const NO_SYNONYMS  = ["no", "nope", "nah", "negative", "not really", "don't", "do not"];
const SERVICE_SYNONYMS = ["service","support","help","representative","agent","operator","supervisor","customer service","reorder","phone number"];

// ---------- Load Flow JSON (generated by build_flow.js) ----------
let salesFlow;
try {
  salesFlow = require(path.join(__dirname, "flows", "flows_alex_sales.json"));
  console.log("âœ… Loaded sales flow JSON with", Object.keys(salesFlow.states || {}).length, "states");
} catch (err) {
  console.warn("âš ï¸ flows/flows_alex_sales.json not found. Using minimal fallback.");
  salesFlow = {
    states: {
      start: {
        say: "Hello, this is Alex with Health America. How are you doing today?",
        tone: "enthusiastic",
        pauseMs: 900,
        next: "reason_for_call"
      },
      reason_for_call: {
        say: "The reason Iâ€™m calling is to follow up on the information we sent out. Did you get that okay?",
        tone: "enthusiastic",
        next: "catch_all"
      },
      catch_all: {
        say: `If you need immediate assistance, our care line is ${HOTLINE}.`,
        tone: "empathetic",
        end: true
      }
    }
  };
}

const app = express();
app.use(bodyParser.json());

// ---------- ENV ----------
const SHEET_ID = process.env.SPREADSHEET_ID;
const VAPI_API_KEY = process.env.VAPI_API_KEY;
const ASSISTANT_ID = process.env.ASSISTANT_ID;
const PHONE_NUMBER_ID = process.env.PHONE_NUMBER_ID;
const APPS_SCRIPT_URL = process.env.APPS_SCRIPT_URL;

const ZOHO_CLIENT_ID = process.env.ZOHO_CLIENT_ID;
const ZOHO_CLIENT_SECRET = process.env.ZOHO_CLIENT_SECRET;
const ZOHO_TOKEN_URL = process.env.ZOHO_TOKEN_URL || "https://accounts.zoho.com/oauth/v2/token";
const ZOHO_REDIRECT = process.env.ZOHO_REDIRECT || "https://vapi-mood.onrender.com/oauth/zoho/callback";

// ---------- Google Auth ----------
function getAuth() {
  const base64Key = process.env.GOOGLE_SERVICE_ACCOUNT;
  if (!base64Key) throw new Error("Missing GOOGLE_SERVICE_ACCOUNT (base64 JSON).");
  const jsonKey = JSON.parse(Buffer.from(base64Key, "base64").toString("utf8"));
  return new google.auth.GoogleAuth({
    credentials: jsonKey,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"],
  });
}

// ---------- Helpers ----------
function normalizeYesNo(inputRaw = "") {
  const s = inputRaw.trim().toLowerCase();
  if (YES_SYNONYMS.some(x => s.includes(x))) return "yes";
  if (NO_SYNONYMS.some(x => s.includes(x))) return "no";
  return null;
}
function mentionsService(inputRaw = "") {
  const s = inputRaw.trim().toLowerCase();
  return SERVICE_SYNONYMS.some(x => s.includes(x));
}
function humanCents(amount) {
  // Converts 89.99 -> "eighty-nine dollars and ninety-nine cents"
  // Basic formatter (US); adjust as needed or swap to a more robust NLG if desired.
  const dollars = Math.floor(amount);
  const cents = Math.round((amount - dollars) * 100);
  const dollarsWords = toWords(dollars);
  const centsWords = toWords(cents);
  return `${dollarsWords} ${dollars === 1 ? "dollar" : "dollars"}${cents ? ` and ${centsWords} ${cents === 1 ? "cent" : "cents"}` : ""}`;
}
// Tiny number-to-words (0..9999) for currency readouts
function toWords(n) {
  const a=["zero","one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen"];
  const b=["","","twenty","thirty","forty","fifty","sixty","seventy","eighty","ninety"];
  if (n<20) return a[n];
  if (n<100) return b[Math.floor(n/10)] + (n%10? "-" + a[n%10]:"");
  if (n<1000) return a[Math.floor(n/100)] + " hundred" + (n%100? " " + toWords(n%100):"");
  if (n<10000) return a[Math.floor(n/1000)] + " thousand" + (n%1000? " " + toWords(n%1000):"");
  return String(n);
}

function fmtStateCityZip(city, state, zip) {
  // Speak full state, not abbreviation; keep US states simple map
  const states = {
    AL:"Alabama", AK:"Alaska", AZ:"Arizona", AR:"Arkansas", CA:"California", CO:"Colorado", CT:"Connecticut",
    DE:"Delaware", FL:"Florida", GA:"Georgia", HI:"Hawaii", ID:"Idaho", IL:"Illinois", IN:"Indiana", IA:"Iowa",
    KS:"Kansas", KY:"Kentucky", LA:"Louisiana", ME:"Maine", MD:"Maryland", MA:"Massachusetts", MI:"Michigan",
    MN:"Minnesota", MS:"Mississippi", MO:"Missouri", MT:"Montana", NE:"Nebraska", NV:"Nevada", NH:"New Hampshire",
    NJ:"New Jersey", NM:"New Mexico", NY:"New York", NC:"North Carolina", ND:"North Dakota", OH:"Ohio",
    OK:"Oklahoma", OR:"Oregon", PA:"Pennsylvania", RI:"Rhode Island", SC:"South Carolina", SD:"South Dakota",
    TN:"Tennessee", TX:"Texas", UT:"Utah", VT:"Vermont", VA:"Virginia", WA:"Washington", WV:"West Virginia",
    WI:"Wisconsin", WY:"Wyoming", DC:"District of Columbia"
  };
  const stateFull = states[(state||"").toUpperCase()] || state || "";
  return `${city}, ${stateFull}, ${zip}`;
}

function formatAddressForSpeech(street, city, state, zip) {
  // Add tiny commas via SSML breaks, plus proper â€œStreetâ€ pause
  const loc = fmtStateCityZip(city, state, zip);
  return `${street}<break time="300ms"/> ${loc}`;
}

// Escape XML for SSML
function escapeXml(s) {
  return String(s).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

// Tone map
const toneMap = {
  enthusiastic:       { pitch: "+5%",  rate: "+15%", volume: "loud"   },
  empathetic:         { pitch: "-5%",  rate: "-10%", volume: "soft"   },
  authoritative:      { pitch: "-3%",  rate: "0%",   volume: "loud"   },
  calm_confidence:    { pitch: "0%",   rate: "-5%",  volume: "medium" },
  absolute_certainty: { pitch: "-8%",  rate: "-5%",  volume: "x-loud" },
  neutral:            { pitch: "0%",   rate: "0%",   volume: "medium" },
};

// Build SSML with optional pause
function toSSML(text, settings, pauseMs) {
  const pitch = settings.pitch || "0%";
  const rate  = settings.rate  || "0%";
  const vol   = settings.volume|| "medium";
  const pause = pauseMs ? `<break time="${pauseMs}ms"/>` : "";
  // Strip internal directives like [PAUSE_900] or {COMPLIMENT_YOUTHFULNESS}
  const spoken = text.replace(/\[PAUSE_\d+\]/gi, "").replace(/\{COMPLIMENT_YOUTHFULNESS\}/gi, "");
  return `<speak><prosody pitch="${pitch}" rate="${rate}" volume="${vol}">${escapeXml(spoken)}${pause}</prosody></speak>`;
}

// Compliment youthfulness generator (donâ€™t say the directive)
function complimentYouthfulness(age) {
  if (!age) return "";
  const lines = [
    "You sound greatâ€”much younger than that.",
    "Honestly, you donâ€™t sound a day over " + Math.max(25, Math.min(age - 5, age)) + ".",
    "You have a youthful energy in your voice."
  ];
  return lines[Math.floor(Math.random() * lines.length)];
}

// In-memory sessions
const sessions = {};
function getSession(sessionId) {
  if (!sessions[sessionId]) sessions[sessionId] = { state: "start", data: {} };
  return sessions[sessionId];
}

// State transition
function handleTransition(session, userInput = "") {
  const current = salesFlow.states[session.state];
  if (!current) { session.state = "catch_all"; return; }

  // capture slot
  if (current.capture) {
    session.data[current.capture] = userInput;
    // Special: if capturing age, auto-attach compliment (without speaking keywords)
    if (current.capture === "age_years") {
      session.data._youthCompliment = complimentYouthfulness(parseInt(userInput, 10));
    }
  }

  // branch logic with slang
  if (current.branches) {
    const yn = normalizeYesNo(userInput);
    if (yn === "yes" && current.branches.yes) { session.state = current.branches.yes; return; }
    if (yn === "no"  && current.branches.no)  { session.state = current.branches.no;  return; }
    if (mentionsService(userInput) && current.branches.service) { session.state = current.branches.service; return; }
    session.state = current.branches.hesitate || current.next || "catch_all";
  } else if (current.next) {
    session.state = current.next;
  } else {
    session.state = "catch_all";
  }
}

// Currency spoken rule for prices inside templates like {{price}}
function renderHumanPrice(rawPrice) {
  const val = Number(rawPrice);
  if (!isFinite(val)) return String(rawPrice);
  return humanCents(val);
}

// ---------- Routes ----------

// Health check
app.get("/", (req, res) => {
  res.send("âœ… Vapi Webhook is running! Endpoints: /start-batch, /vapi-webhook, /vapi-callback, /oauth/zoho/callback");
});

// Start batch (5 at a time by your Apps Script; this endpoint fires the next N pending)
app.get("/start-batch", async (req, res) => {
  try {
    if (!SHEET_ID) throw new Error("Missing SPREADSHEET_ID");
    if (!VAPI_API_KEY) throw new Error("Missing VAPI_API_KEY");

    const auth = await getAuth();
    const sheets = google.sheets({ version: "v4", auth });

    const range = `${SHEET_NAME}!A:Z`;
    const response = await sheets.spreadsheets.values.get({ spreadsheetId: SHEET_ID, range });
    const rows = response.data.values || [];
    if (rows.length < 2) return res.json({ started: [], message: "No rows found" });

    const headers = rows[0].map(h => (h||"").toLowerCase());
    const idIdx = headers.indexOf("id");
    const phoneIdx = headers.indexOf("phone");
    const statusIdx = headers.indexOf("status");
    if (idIdx===-1 || phoneIdx===-1 || statusIdx===-1) throw new Error("Sheet needs id, phone, status columns.");

    const dataRows = rows.slice(1);
    const nextFive = dataRows
      .map((row, i) => ({ row, i }))
      .filter(r => !r.row[statusIdx] || (r.row[statusIdx]+"").toLowerCase() === "pending")
      .slice(0, 5);

    const results = [];
    for (const entry of nextFive) {
      const { row, i } = entry;
      const rowIndex = i + 2;
      const id = row[idIdx];
      const phone = row[phoneIdx];
      if (!phone) { results.push({ id, phone, error: "No phone" }); continue; }

      const payload = {
        assistantId: ASSISTANT_ID,
        phoneNumberId: PHONE_NUMBER_ID,
        customer: { number: phone },
        metadata: { id, rowIndex }
      };

      const vapiResp = await fetch("https://api.vapi.ai/call", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${VAPI_API_KEY}`,
        },
        body: JSON.stringify(payload),
      });

      const txt = await vapiResp.text();
      let json; try { json = JSON.parse(txt); } catch { json = { raw: txt }; }
      results.push({ id, phone, response: json });
    }

    res.json({ started: results });
  } catch (err) {
    console.error("start-batch error:", err);
    res.status(500).send("Error: " + (err.message || String(err)));
  }
});

// Vapi callback (write back to Sheet; forward to Apps Script)
app.post("/vapi-callback", async (req, res) => {
  try {
    const { metadata, status, result } = req.body || {};
    const id = metadata?.id; const rowIndex = metadata?.rowIndex;
    if (!SHEET_ID) throw new Error("Missing SPREADSHEET_ID");
    if (!id || !rowIndex) throw new Error("Missing metadata.id or rowIndex");

    const timestamp = new Date().toISOString();
    const auth = await getAuth();
    const sheets = google.sheets({ version: "v4", auth });

    const headerResp = await sheets.spreadsheets.values.get({ spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!A1:Z1` });
    const headers = (headerResp.data.values?.[0] || []).map(h => (h||"").toLowerCase());
    const statusIdx = headers.indexOf("status")+1;
    const attemptsIdx = headers.indexOf("attempts")+1;
    const lastAttemptIdx = headers.indexOf("lastattemptat")+1;
    const resultIdx = headers.indexOf("result")+1;

    const attemptsResp = await sheets.spreadsheets.values.get({
      spreadsheetId: SHEET_ID, range: `${SHEET_NAME}!R${rowIndex}C${attemptsIdx}`
    });
    const currentAttempts = parseInt(attemptsResp.data.values?.[0]?.[0] || "0", 10);

    const updates = [
      { range: `${SHEET_NAME}!R${rowIndex}C${statusIdx}`, values: [[status || "completed"]] },
      { range: `${SHEET_NAME}!R${rowIndex}C${attemptsIdx}`, values: [[currentAttempts + 1]] },
      { range: `${SHEET_NAME}!R${rowIndex}C${lastAttemptIdx}`, values: [[timestamp]] },
      { range: `${SHEET_NAME}!R${rowIndex}C${resultIdx}`, values: [[typeof result === "string" ? result : JSON.stringify(result||{})]] },
    ];
    await sheets.spreadsheets.values.batchUpdate({
      spreadsheetId: SHEET_ID, requestBody: { valueInputOption: "RAW", data: updates }
    });

    // forward raw callback to Apps Script
    if (APPS_SCRIPT_URL) {
      try {
        await fetch(APPS_SCRIPT_URL, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(req.body) });
      } catch (fwd) { console.warn("Apps Script forward failed:", fwd?.message || fwd); }
    }

    res.send("OK");
  } catch (err) {
    console.error("vapi-callback error:", err);
    res.status(500).send("Error: " + (err.message || String(err)));
  }
});

// Conversation webhook: returns next state with SSML + pauseMs
app.post("/vapi-webhook", (req, res) => {
  try {
    const { sessionId, userInput } = req.body || {};
    if (!sessionId) return res.status(400).json({ error: "Missing sessionId" });

    const session = getSession(sessionId);
    if (typeof userInput === "string" && userInput.trim()) handleTransition(session, userInput);

    const current = salesFlow.states[session.state];
    if (!current) {
      const text = `If you need anything, our customer care line is ${HOTLINE}.`;
      const settings = toneMap.neutral;
      return res.json({ say: text, tone: "neutral", voice: settings, ssml: toSSML(text, settings, 600), pauseMs: 600, format: "ssml", end: true });
    }

    // Inject youth compliment after age capture (do not speak directive)
    let text = current.say || "Letâ€™s continue.";
    if (session.data._youthCompliment && current._injectYouthCompliment) {
      text = `${text} ${session.data._youthCompliment}`;
    }

    // Normalize â€œ5â€“7â€ phrasing
    text = text.replace(/five[\s-]?seven days/gi, "five to seven days");

    // Replace {{human_price}} if present
    text = text.replace(/\{\{\s*human_price\s*\}\}/g, () => renderHumanPrice(Number(session.data._price || 0)));

    const tone = current.tone || "neutral";
    const settings = toneMap[tone] || toneMap.neutral;
    const pauseMs = current.pauseMs || 0;

    return res.json({
      say: text.replace(/\[PAUSE_\d+\]/gi, "").replace(/\{COMPLIMENT_YOUTHFULNESS\}/gi, ""),
      tone,
      voice: settings,
      ssml: toSSML(text, settings, pauseMs),
      pauseMs,
      format: "ssml",
      end: !!current.end
    });
  } catch (err) {
    console.error("vapi-webhook error:", err);
    res.status(500).json({ error: err.message || String(err) });
  }
});

// Zoho OAuth callback (to generate refresh token for your records)
app.get("/oauth/zoho/callback", async (req, res) => {
  const { code } = req.query;
  if (!code) return res.status(400).send("Missing ?code=");
  try {
    const tokenResp = await fetch(ZOHO_TOKEN_URL, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({
        code,
        client_id: ZOHO_CLIENT_ID,
        client_secret: ZOHO_CLIENT_SECRET,
        redirect_uri: ZOHO_REDIRECT,
        grant_type: "authorization_code",
      }),
    });
    const json = await tokenResp.json();
    console.log("ðŸ” Zoho token exchange result:", json);
    res.send("âœ… Token exchange complete. Copy your refresh_token from server logs.");
  } catch (err) {
    console.error("Zoho callback error:", err);
    res.status(500).send("Error exchanging Zoho code.");
  }
});

// ---------- Start ----------
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`ðŸš€ Server running on ${PORT}`));
